/*!
 * rein v0.0.1
 * (c) 2020 Jacob Schatz
 * @license MIT
 */
!(function (e, n) {
  "object" == typeof exports && "undefined" != typeof module
    ? (module.exports = n())
    : "function" == typeof define && define.amd
    ? define(n)
    : ((e = e || self).Rien = n());
})(this, function () {
  "use strict";
  let e,
    n,
    t,
    o = !1,
    i = {},
    r = "";
  function c(e) {
    if (!e) return;
    const n = Object.keys(e);
    let t = {};
    return (
      n.forEach(function (n) {
        const o = function () {
          return e[n];
        };
        Object.defineProperty(o, "name", { value: n, writable: !1 }),
          (t[n] = o);
      }),
      t
    );
  }
  function s(e) {
    return (function (e, n) {
      if (!e) return;
      let t = {};
      return (
        Object.keys(e).forEach(function (o) {
          const r = function (...t) {
            e[o].apply(null, [{ state: i[n] }, ...t]);
          };
          Object.defineProperty(r, "name", { value: o, writable: !1 }),
            (t[o] = r);
        }),
        t
      );
    })(n[e].mediator, e);
  }
  function a() {
    const a = this.$options;
    if (a.rien) {
      if ((a.rien.namespaced && (o = a.rien.namespaced), !a.rien.viewModels))
        throw Error("[Rien warn] Missing `viewModel` property of rien object");
      (n = a.rien.viewModels),
        (i = {}),
        Object.keys(n).forEach(function (e) {
          i[e] = n[e].state;
        }),
        (t = new e({ data: { __vmState: i } })),
        a.rien.baseURL &&
          ((r = a.rien.baseURL),
          Object.keys(n).forEach(function (e) {
            const t = Object.keys(n[e].service);
            t.length &&
              t.forEach(function (t) {
                const o = n[e].service[t],
                  i = `${r}/${e}`;
                (o.index = function () {
                  return fetch(i).then((e) => e.json());
                }),
                  (o.create = function (e) {
                    return fetch(i, {
                      headers: {
                        Accept: "application/json",
                        "Content-Type": "application/json",
                      },
                      method: "POST",
                      body: JSON.stringify(e),
                    }).then((e) => e.json());
                  }),
                  (o.show = function (e) {
                    return fetch(`${i}/${e}`).then((e) => e.json());
                  }),
                  (o.update = function (e, n) {
                    return fetch(`${i}/${e}`, {
                      headers: {
                        Accept: "application/json",
                        "Content-Type": "application/json",
                      },
                      method: "PUT",
                      body: JSON.stringify(n),
                    }).then((e) => e.json());
                  }),
                  (o.delete = function (e) {
                    return fetch(`${i}/${e}`, { method: "DELETE" }).then((e) =>
                      e.json()
                    );
                  });
              });
          }));
    } else
      a.parent &&
        n[a.name] &&
        ((this.$options.computed = {
          ...(a.computed ? a.computed : {}),
          ...((f = a.name), c(o ? n[f].state : n[f].state[f])),
        }),
        (this.$options.methods = {
          ...(a.methods ? a.methods : {}),
          ...s(a.name),
        }));
    var f;
  }
  return {
    install: function (n) {
      e && n === e
        ? __DEV__ &&
          console.error(
            "[rien] already installed. Vue.use(Rein) should be called only once."
          )
        : ((e = n),
          (function (e) {
            e.mixin({ beforeCreate: a });
          })(e));
    },
  };
});
